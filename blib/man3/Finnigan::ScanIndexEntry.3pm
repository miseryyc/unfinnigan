.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Finnigan::ScanIndexEntry 3pm"
.TH Finnigan::ScanIndexEntry 3pm "2011-06-20" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Finnigan::ScanIndexEntry \-\- a decoder for ScanIndexEntry, a linked list element pointing to scan data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Finnigan;
\&  my $entry = Finnigan::ScanIndexEntry\->decode(\e*INPUT, $VERSION);
\&  say $entry\->offset; # returns an offset from the start of scan data stream 
\&  say $entry\->data_size;
\&  $entry\->dump;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
ScanIndexEntry is a static (fixed-size) structure containing the
pointer to a scan, the scan's data size and some auxiliary information
about the scan.
.PP
Scan Index elements seem to form a linked list. Each ScanIndexEntry
contains the index of the next entry.
.PP
Although in all observed instances the scans were sequential and their
indices could be ignored, it may not always be the case.
.PP
It is not clear whether scan index numbers start at 0 or at 1. If they
start at 0, the list link index must point to the next item. If they
start at 1, then \*(L"index\*(R" will become \*(L"previous\*(R" and \*(L"next\*(R" becomes
\&\*(L"index\*(R" \*(-- the list will be linked from tail to head. Although
observations are lacking, I am inclined to interpret it as a
forward-linked list, simply from common sense.
.PP
Note: The \*(L"current/next\*(R" theory of the two ordinal numbers in this
structure may be totally wrong. It may just be that one of these
numbers is the 0\-base index (0 .. n \-1), and the other is 1\-based: (1
\&.. n). It is suspicious that in the last entry in every stream, the
\&\*(L"next\*(R" value is not null, it simply n.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.ie n .IP "decode($stream, $version)" 4
.el .IP "decode($stream, \f(CW$version\fR)" 4
.IX Item "decode($stream, $version)"
The constructor method
.IP "offset" 4
.IX Item "offset"
Get the address of the corresponding ScanDataPacket relative to the
start of the data stream
.IP "index" 4
.IX Item "index"
Get this element's index (a valid assumption if the scan data indices
start at 0, otherwise this is the previous element's index)
.IP "next" 4
.IX Item "next"
Get the next element's index(a valid assumption if the scan data
indices start at 0, otherwise this is the current element's index)
.IP "scan_event" 4
.IX Item "scan_event"
Get the index of this element's ScanEventTemplate in the current scan
segment
.IP "scan_segment" 4
.IX Item "scan_segment"
Get the index of this element's scan segment in Scan Event Hierarchy
.IP "data_size" 4
.IX Item "data_size"
Get the size of the ScanDataPacket this index element is pointing to
.IP "start_time" 4
.IX Item "start_time"
Get the current scan's start time
.IP "total_current" 4
.IX Item "total_current"
Get the scan's total current (a rough indicator of how many ions were
scanned)
.IP "base_intensity" 4
.IX Item "base_intensity"
Get the intensity of the most abundant ion
.IP "base_mz" 4
.IX Item "base_mz"
Get the M/z value of the most abundant ion
.IP "low_mz" 4
.IX Item "low_mz"
Get the low end of the scan range
.IP "high_mz" 4
.IX Item "high_mz"
Get the high end of the scan range
.IP "unknown" 4
.IX Item "unknown"
Get the only unknown UInt32 stored in the index entry. Its value (or
some bits in it) seem to correspond to the type of scan, but its
interpretation is uncertain.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Finnigan::Profile
.PP
Finingan::Peaks
.PP
Finnigan::Scan
.PP
uf-index
.SH "AUTHOR"
.IX Header "AUTHOR"
Gene Selkov, <selkovjr@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by Gene Selkov
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.10.0 or,
at your option, any later version of Perl 5 you may have available.
