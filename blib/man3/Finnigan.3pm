.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Finnigan 3pm"
.TH Finnigan 3pm "2011-06-20" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Finnigan \- Thermo/Finnigan mass spec data decoder
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Finnigan;
\&
\&  seek INPUT, $object_address, 0
\&  my $o = Finnigan::Object\->decode(\e*STREAM, $arg);
\&  $o\->dump;
.Ve
.PP
where 'Object' is a symbol for any of the specific decoder objects
(\f(CW\*(C`Finnigan::*\*(C'\fR) and \f(CW\*(C`STREAM\*(C'\fR is an open filehandle positioned at the
start of the structure to be decoded. Some decoders may require an
additional argument (file format version).
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Finnigan\*(C'\fR is a non-functional package whose only purpose is to pull
in all other packages in the module into its namespace. It does no
work; all work is done in the sub-modules. Each submodule has its own
documentation; please see the \*(L"\s-1SUBMODULES\s0\*(R" section below or visit
the project's home page <http://code.google.com/p/unfinnigan> for a
more detailed descripion of the file format, data structures, decoders
and tools.
.PP
Each decoder submodule has a simple command-line interface. See the
\&\*(L"\s-1TOOLS\s0\*(R" section for a list of command-line tools that can be used to
examine the Finnigan file structures and dump their contents with
absolute or relative addresses. One of the tools, uf-mzxml, can be
used to convert the entire data stream in a Finnigan file to the
mzXML <http://sashimi.sourceforge.net/software_glossolalia.html>
format.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "list_modules" 4
.IX Item "list_modules"
The only method defined in the top-level \f(CW\*(C`Finnigan\*(C'\fR package is
\&\f(CW\*(C`list_modules\*(C'\fR, which can be used to ascertain that all packages have
been successfully loaded:
.Sp
.Vb 1
\&  perl \-MFinnigan \-e \*(AqFinnigan::list_modules\*(Aq
.Ve
.SS "\s-1SUBMODULES\s0"
.IX Subsection "SUBMODULES"
To simplify the decoder and allow it to accommodate a variety of file
versions, it has been subdivided into a set of submodules, each
representing a structural unit of the Finnigan file format. The
partitioning of the format into units is somewhat arbitrary; it was
done based on the comparative analysis of the structure of several
different formats. The structures common to all formats are viewed as
\&\*(L"basic\*(R" and merit a dedicated decoder; the same goes for the highly
repetitive structures, such as Finnigan::ScanIndexEntry. Some
structures remain roughly similar, but keep acquiring new elements
with every new file version; the decoders for these structures are
parameterised with the version number (for example,
Finnigan::ScanEventPreamble).
.PP
The notion of a \fIpreamble\fR (the term I made up, not knwoing better)
represents what seems to be a persistent idiom in Thermo structure
coding: collect the binary data in a fixed-size block followed by
variable-length objects (mostly text strings). The earlier Finnigan
formats contained little or no text and virtually no variable-length
data, so what I call a preamble today used to be the whole deal in the
past, and it makes sense to have a separate decoder for each such
rudimentary container. Keeping these decoders separate makes it
possible to go back and decode the historical data simply by
recombining the existing decoders.
.PP
\fICommon submodule methods\fR
.IX Subsection "Common submodule methods"
.ie n .IP "decode($stream, $arg)" 4
.el .IP "decode($stream, \f(CW$arg\fR)" 4
.IX Item "decode($stream, $arg)"
Each \f(CW\*(C`Finnigan::*\*(C'\fR object has a constructor method named \f(CW\*(C`decode()\*(C'\fR,
whose first argument is a filehandle positioned at the start of the
object to be decoded. Some decoders require additional arguments, such
as the file version number. A single argument is passed as it is,
while multiple arguments can be passed as an array reference.
.Sp
The constructor advances the handle to the start of the next object,
so seeking to the start of the object of interest is only necessary
when doing partial reads; in principle, the entire file can be read by
calling of object constructors in sequency. In reality, it is often
more efficient to seek ahead to fetch an index structure stored near
the end of the file, then go back to the data stream using the
pointers in the index.
.Sp
The decoded data can be obtained by calling accessor methods on the
object or by de-referencing the object reference (since all Finnigan
objects are blessed hash references):
.Sp
.Vb 1
\&  $x = $object\->element
.Ve
.Sp
or
.Sp
.Vb 1
\&  $x = $object\->{element}
.Ve
.Sp
The accessor option is nicer, as it leads to less clutter in the code
and leaves the possibility for additional processing of the data by the
accessor routine, but it incurs a substantial performance penalty. For
this reason, hash dereference is preferred in performance-critical
code (inside loops).
.Sp
This is an \*(L"instance\*(R" method; it must be defined in each non-trivial
decoder object.
.IP "dump(%args)" 4
.IX Item "dump(%args)"
All Finnigan objects are the descendants of Finnigan::Decoder. One
of the methods they inherit is \f(CW\*(C`dump\*(C'\fR, which provides an easy way to
explore the contents of decoded objects. The \f(CW\*(C`dump\*(C'\fR method prints out
the structure of the object it is called on in a few styles, with
relative or absolute addressess.
.Sp
For example, many object dumps used in this
wiki <http://code.google.com/p/unfinnigan/wiki/WikiHome> were created
thus:
.Sp
.Vb 1
\&  $object\->dump(style => \*(Aqwiki\*(Aq, relative => 1);
.Ve
.Sp
The \f(CW\*(C`style\*(C'\fR argument can have the values of \f(CW\*(C`wiki\*(C'\fR, \f(CW\*(C`html\*(C'\fR or no
value at all (meaning plain text). The \f(CW\*(C`relative\*(C'\fR argument is a
boolean indicating whether to use the absolute or relative file
addresses in the output. In this case, \*(L"relative\*(R" means \*(L"an offset
within the object\*(R", while \*(L"absolute\*(R" is the seek address within the
data file.
.ie n .IP "read($stream, $template_list, $arg)" 4
.el .IP "read($stream, \f(CW$template_list\fR, \f(CW$arg\fR)" 4
.IX Item "read($stream, $template_list, $arg)"
This is the \f(CW\*(C`Finnigan::Decoder\*(C'\fR constructor method. Some derived
decoders use it internally, but it can also be used to decode trivial
objects at a given location in a file without having to write a
dedicated decoder.
.Sp
For example, to read a 32\-bit stream length, use:
.Sp
.Vb 1
\&  my $object = Finnigan::Decoder\->read(\e*INPUT, [\*(Aqlength\*(Aq => [\*(AqV\*(Aq, \*(AqUInt32\*(Aq]]);
.Ve
.Sp
The \f(CW$template_list\fR argument names all fields to decode (in this
case, just one: \f(CW\*(C`length\*(C'\fR), the template to use for each field (in
this example, \f(CW\*(C`V\*(C'\fR), and provides a human-readable symbol for the
template, which can be used in a number of ways; for example, when
inspecting the structures with the \f(CW\*(C`dump\*(C'\fR method.
.Sp
This may seem like a kludgy way of reading four bytes, but the upshot
is that the resulting \f(CW$object\fR will have the size, type and location
information tucked into it, so it can be analysed and dumped in a way
consistent with other decoded objects. The advantage becomes even more
apparent when the structure is more complex than a single scalar object.
.Sp
The inherited \f(CW\*(C`read\*(C'\fR method provides the core functionality in all Finnigan
decoders.
.Sp
If only the value of the object is sought, then this even more kludgy
code can be used:
.Sp
.Vb 1
\&  my $stream_length = Finnigan::Decoder\->read(\e*INPUT, [\*(Aqlength\*(Aq => [\*(AqV\*(Aq, \*(AqUInt32\*(Aq]])\->{data}\->{length}\->{value};
.Ve
.Sp
Doing it this way is nonetheless easier than writing several lines of
code to read the data into a buffer, check for the I/O errors and
unpack the value.
.IP "stringify" 4
.IX Item "stringify"
A convenience method defined in some of the Finnigan objects. It
allows a concise representation of an object to be injected anywhere
Perl expects a string. For example,
.Sp
.Vb 2
\&  $scan_event = Finnigan::ScanEvent\->decode( \e*INPUT, $header\->version);
\&  say "$scan_event";
.Ve
.PP
\fISubmodule index\fR
.IX Subsection "Submodule index"
.IP "Finnigan::AuditTag (sample audit tag)" 4
.IX Item "Finnigan::AuditTag (sample audit tag)"
.PD 0
.IP "Finnigan::CASInfo (autosampler info)" 4
.IX Item "Finnigan::CASInfo (autosampler info)"
.IP "Finnigan::CASInfoPreamble (numerical autosampler parameters)" 4
.IX Item "Finnigan::CASInfoPreamble (numerical autosampler parameters)"
.IP "Finnigan::Decoder (the base class for all Finnigan decoders)" 4
.IX Item "Finnigan::Decoder (the base class for all Finnigan decoders)"
.IP "Finnigan::Error (error log entry)" 4
.IX Item "Finnigan::Error (error log entry)"
.IP "Finnigan::FileHeader" 4
.IX Item "Finnigan::FileHeader"
.IP "Finnigan::FractionCollector (M/z range decoder)" 4
.IX Item "Finnigan::FractionCollector (M/z range decoder)"
.IP "Finnigan::GenericDataDescriptor (a self-decoding structure element)" 4
.IX Item "Finnigan::GenericDataDescriptor (a self-decoding structure element)"
.IP "Finnigan::GenericDataHeader (self-decoding structure header)" 4
.IX Item "Finnigan::GenericDataHeader (self-decoding structure header)"
.IP "Finnigan::GenericRecord (self-decoding structure)" 4
.IX Item "Finnigan::GenericRecord (self-decoding structure)"
.IP "Finnigan::InjectionData (sample injection parameters)" 4
.IX Item "Finnigan::InjectionData (sample injection parameters)"
.IP "Finnigan::InstID (instrument identifiers)" 4
.IX Item "Finnigan::InstID (instrument identifiers)"
.IP "Finnigan::InstrumentLogRecord (instrument log entry)" 4
.IX Item "Finnigan::InstrumentLogRecord (instrument log entry)"
.IP "Finnigan::MethodFile (an \s-1OLE2\s0 container for instrument method files)" 4
.IX Item "Finnigan::MethodFile (an OLE2 container for instrument method files)"
.IP "Finnigan::OLE2DIF (Double-Indirect \s-1FAT\s0 decoder)" 4
.IX Item "Finnigan::OLE2DIF (Double-Indirect FAT decoder)"
.IP "Finnigan::OLE2DirectoryEntry" 4
.IX Item "Finnigan::OLE2DirectoryEntry"
.IP "Finnigan::OLE2FAT (\s-1FAT\s0 sector decoder)" 4
.IX Item "Finnigan::OLE2FAT (FAT sector decoder)"
.IP "Finnigan::OLE2File (Microsoft \s-1OLE2/CDF\s0 file decoder)" 4
.IX Item "Finnigan::OLE2File (Microsoft OLE2/CDF file decoder)"
.IP "Finnigan::OLE2Header (\s-1OLE2\s0 header decoder)" 4
.IX Item "Finnigan::OLE2Header (OLE2 header decoder)"
.IP "Finnigan::OLE2Property (\s-1OLE2\s0 index node decoder)" 4
.IX Item "Finnigan::OLE2Property (OLE2 index node decoder)"
.IP "Finnigan::PacketHeader (scan data header)" 4
.IX Item "Finnigan::PacketHeader (scan data header)"
.IP "Finnigan::Peak (an element of the peak centroid list)" 4
.IX Item "Finnigan::Peak (an element of the peak centroid list)"
.IP "Finnigan::Peaks (the peak centroid list)" 4
.IX Item "Finnigan::Peaks (the peak centroid list)"
.IP "Finnigan::Profile (scan profile)" 4
.IX Item "Finnigan::Profile (scan profile)"
.IP "Finnigan::ProfileChunk (a single chunk of a filetered profile)" 4
.IX Item "Finnigan::ProfileChunk (a single chunk of a filetered profile)"
.IP "Finnigan::RawFileInfo (primary index structure)" 4
.IX Item "Finnigan::RawFileInfo (primary index structure)"
.ie n .IP "Finnigan::RawFileInfoPreamble (the binary data part of ""RawFileInfo"")" 4
.el .IP "Finnigan::RawFileInfoPreamble (the binary data part of \f(CWRawFileInfo\fR)" 4
.IX Item "Finnigan::RawFileInfoPreamble (the binary data part of RawFileInfo)"
.IP "Finnigan::Reaction (precursor ion data)" 4
.IX Item "Finnigan::Reaction (precursor ion data)"
.IP "Finnigan::RunHeader (secondary index structure)" 4
.IX Item "Finnigan::RunHeader (secondary index structure)"
.IP "Finnigan::SampleInfo (secondary index structure)" 4
.IX Item "Finnigan::SampleInfo (secondary index structure)"
.ie n .IP "Finnigan::Scan (a lightweight ""ScanDataPacket"" decoder)" 4
.el .IP "Finnigan::Scan (a lightweight \f(CWScanDataPacket\fR decoder)" 4
.IX Item "Finnigan::Scan (a lightweight ScanDataPacket decoder)"
.IP "Finnigan::ScanEvent (scan type descriptor)" 4
.IX Item "Finnigan::ScanEvent (scan type descriptor)"
.ie n .IP "Finnigan::ScanEventPreamble (the byte array component of ""ScanEvent"")" 4
.el .IP "Finnigan::ScanEventPreamble (the byte array component of \f(CWScanEvent\fR)" 4
.IX Item "Finnigan::ScanEventPreamble (the byte array component of ScanEvent)"
.IP "Finnigan::ScanEventTemplate (the prototype scan descriptor)" 4
.IX Item "Finnigan::ScanEventTemplate (the prototype scan descriptor)"
.IP "Finnigan::ScanIndexEntry (scan data pointer)" 4
.IX Item "Finnigan::ScanIndexEntry (scan data pointer)"
.IP "Finnigan::ScanParameters (scan meta-data)" 4
.IX Item "Finnigan::ScanParameters (scan meta-data)"
.IP "Finnigan::SeqRow (sequencer table row)" 4
.IX Item "Finnigan::SeqRow (sequencer table row)"
.PD
.SS "\s-1TOOLS\s0"
.IX Subsection "TOOLS"
The Unfinnigan tools extract data from the Finnigan files of several
known versions. They are listed roughly in the order in which the
structures they decode occur in the data file.
.PP
\fIQuery tools\fR
.IX Subsection "Query tools"
.IP "uf-header" 4
.IX Item "uf-header"
read the \f(CW\*(C`FileHeader\*(C'\fR structure
.IP "uf-seqrow" 4
.IX Item "uf-seqrow"
read the \f(CW\*(C`SeqRow\*(C'\fR structure (Sequence Table Row)
.IP "uf-casinfo" 4
.IX Item "uf-casinfo"
read the \f(CW\*(C`CASInfo\*(C'\fR structure (autosampler info)
.IP "uf-rfi" 4
.IX Item "uf-rfi"
read \f(CW\*(C`RawFileInfo\*(C'\fR, the primary index structure
.IP "uf-meth" 4
.IX Item "uf-meth"
unravel the embedded \f(CW\*(C`MethodFile\*(C'\fR container
.IP "uf-scan" 4
.IX Item "uf-scan"
examine the scan profile and peak data in a single \s-1MS\s0 scan (\f(CW\*(C`ScanDataPacket\*(C'\fR)
.IP "uf-runheader" 4
.IX Item "uf-runheader"
read \f(CW\*(C`RunHeader\*(C'\fR), the secondary index structure
.IP "uf-instrument" 4
.IX Item "uf-instrument"
read the instrument IDs (the \f(CW\*(C`InstID\*(C'\fR structure)
.IP "uf-log" 4
.IX Item "uf-log"
list or dump the instrument log stream (\f(CW\*(C`InstrumentLogRecord\*(C'\fR structures)
.IP "uf-error" 4
.IX Item "uf-error"
list the error log (a steam of \f(CW\*(C`Error\*(C'\fR structures)
.IP "uf-segments" 4
.IX Item "uf-segments"
dump the \f(CW\*(C`ScanEventTemplate\*(C'\fR structures in the order of segment hierarchy
.IP "uf-params" 4
.IX Item "uf-params"
print or dump the \f(CW\*(C`ScanParameters\*(C'\fR stream
.IP "uf-tune" 4
.IX Item "uf-tune"
print or dump the \f(CW\*(C`TuneFile\*(C'\fR structure
.IP "uf-index" 4
.IX Item "uf-index"
read the stream of \f(CW\*(C`ScanIndexEntry\*(C'\fR records (scan data pointers)
.IP "uf-trailer" 4
.IX Item "uf-trailer"
read the stream of \f(CW\*(C`ScanEvent\*(C'\fR records
.PP
\fIConversion tools\fR
.IX Subsection "Conversion tools"
.PP
The following are the conversion tools, transcoding the entire raw
files into alternative representations.
.IP "uf-mzxml" 4
.IX Item "uf-mzxml"
convert a raw file to mzXML
.IP "mzxml-unpack" 4
.IX Item "mzxml-unpack"
unpack the base64\-encoded scan data in an mzXML file
.PP
All tools contain their own \s-1POD\s0 sections. To read the documentation for a tool, use
.PP
.Vb 2
\&  man <tool>
\&  perldoc <tool>
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Gene Selkov, <selkovjr@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by Gene Selkov
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.10.0 or,
at your option, any later version of Perl 5 you may have available.
