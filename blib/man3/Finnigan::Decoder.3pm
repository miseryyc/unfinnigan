.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Finnigan::Decoder 3pm"
.TH Finnigan::Decoder 3pm "2011-06-20" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Finnigan::Decoder \- a generic binary structure decoder
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Finnigan;
\&
\&  my $fields = [
\&    short_int => \*(Aqv\*(Aq,
\&    long_int => \*(AqV\*(Aq,
\&    ascii_string => \*(AqC60\*(Aq,
\&    wide_string => \*(AqU0C18\*(Aq,
\&    audit_tag => \*(Aqobject=Finnigan::AuditTag\*(Aq,
\&    time => \*(Aqwindows_time\*(Aq,
\&  ];
\&
\&  my $data = Finnigan::Decoder\->read(\e*STREAM, $fields);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is not inteded to be used directly; it is a parent class
for all Finnigan decoders. The fields to decode are passed to
the decoder's \fIread()\fR method in a list reference, where every even item
specifies the key the item will be known as in the resulting hash, and
every odd item specifies the unpack template.
.PP
Perl unpack templates are used to decode most fields. For some fields, non-perl templates are used, such as:
.IP "\(bu" 2
object: instructs the current decoder to call another Finnigan decoder at that location.
.IP "\(bu" 2
windows_time: instructs Finingan::Decoder to call its own Windows timestamp routine.
.IP "\(bu" 2
varstr: decoded as a Windows Pascal string in a special case in the \fIFinnigan::Decoder::read()\fR method.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.ie n .IP "read($class, $stream, $fields, $any_arg)" 4
.el .IP "read($class, \f(CW$stream\fR, \f(CW$fields\fR, \f(CW$any_arg\fR)" 4
.IX Item "read($class, $stream, $fields, $any_arg)"
Returns a new decoder blessed into class \f(CW$class\fR and initialized
with the values read from \f(CW$stream\fR and decoded according to a list
of templates specified in \f(CW$fields\fR.
.Sp
The fourth argument, \f(CW$any_arg\fR is not used by the Decoder class, but
may be used by derived classes to pass parse context to their
component decoders. For example, this can be useful to parse
structures whose layout is governed by the data they contain; in that
case if the layout indicator is read by the top-level decoder, it can
be passed to lower-level decoders whose work depends on it. Also, this
argument is used by the user program to pass the Finnigan file version
to version-sensitive decoders.
.Sp
Here is an example of the template list for a simple decoder:
.Sp
.Vb 4
\&  my $fields = [
\&    "mz"        => [\*(Aqf<\*(Aq, \*(AqFloat32\*(Aq],
\&    "abundance" => [\*(Aqf<\*(Aq, \*(AqFloat32\*(Aq],
\&  ];
.Ve
.ie n .IP "decode($stream, $fields, $any_arg)" 4
.el .IP "decode($stream, \f(CW$fields\fR, \f(CW$any_arg\fR)" 4
.IX Item "decode($stream, $fields, $any_arg)"
This method must be called on a blessed, instantiated Decoder. The
\&\f(CW\*(C`read()\*(C'\fR method calls it internally, but it can also be used by the
user code in those cases where not all data can be decoded with a
plain list of templates. In some cases, it may be necessary to decode
one part of an object, analyse it, make decisions about the rest
(calculate sizes, layouts, etc.), and then grow the object under
construction by decoding more data from the stream.
.ie n .IP "iterate_scalar($stream, $count, $name, $desc)" 4
.el .IP "iterate_scalar($stream, \f(CW$count\fR, \f(CW$name\fR, \f(CW$desc\fR)" 4
.IX Item "iterate_scalar($stream, $count, $name, $desc)"
This method is similar to the \f(CW\*(C`decode\*(C'\fR metod, in that it does not
instantiate a Decoder, but rather adds data to an existing one. Its
purpose is to decode simple arrays whose elements have neither
structure, nor behaviour, and can be described by a simple list. The
list will consist of \f(CW$count\fR elements read into the current
Decoder's attribute given in \f(CW$name\fR, according to the template
specified in \f(CW$desc\fR.  For example, to read a list of 4\-byte
integers, the template description must be of the form:
.Sp
.Vb 1
\&  $desc = [\*(AqV\*(Aq, \*(AqUInt32\*(Aq]
.Ve
.ie n .IP "iterate_object($stream, $count, $name, $class, $any_arg)" 4
.el .IP "iterate_object($stream, \f(CW$count\fR, \f(CW$name\fR, \f(CW$class\fR, \f(CW$any_arg\fR)" 4
.IX Item "iterate_object($stream, $count, $name, $class, $any_arg)"
Similarly to \f(CW\*(C`iterate_scalar()\*(C'\fR, this method can be used to read a
list of structures into the current decoder's attribute specified in
the \f(CW$name\fR argument, but in this case, the list elements can be
complex structures to be decoded with their own decoder specified in
\&\f(CW$class\fR. The optional argument \f(CW$any_arg\fR can be used to parse
context information to that decoder.
.IP "purge_unused_data" 4
.IX Item "purge_unused_data"
Delete the location, size and type data for all structure
elements. Calling this method will free some memory when no
introspection is needeed (the necessary measure in production-grade
code)
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "addr" 4
.IX Item "addr"
Get the seek address of the decoded object
.IP "size" 4
.IX Item "size"
Get object size
.IP "data" 4
.IX Item "data"
Get the object's data hash (equivalent to \f(CW$obj\fR\->{data}). Every data hash element contains the decoded value as well as location and type data.
.IP "item($key)" 4
.IX Item "item($key)"
Get an item by name (equivalent to \f(CW$obj\fR\->{data}\->{$key})
.IP "values" 4
.IX Item "values"
Extract the simple value hash (no location data, only the element names and values)
.IP "dump($param)" 4
.IX Item "dump($param)"
Dump the object's contents in three different styles, using absolute
or relative addresses. The attribute \f(CW$param\fR\->{style} can be set to
wiki or html, or it can be absent or have any other value, it which
case the dump will have a simple tabular format. The attribute
\&\f(CW$param\fR\->{relative}is a Boolean, requesting relative addresses when it
is set to a truthy value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Use this command to list all available Finnigan decoders:
.PP
.Vb 1
\& perl \-MFinnigan \-e \*(AqFinnigan::list_modules\*(Aq
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Gene Selkov, <selkovjr@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by Gene Selkov
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.10.0 or,
at your option, any later version of Perl 5 you may have available.
