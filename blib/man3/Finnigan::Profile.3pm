.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Finnigan::Profile 3pm"
.TH Finnigan::Profile 3pm "2011-06-20" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Finnigan::Profile \-\- a full\-featured decoder for Finnigan scan profiles
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Finnigan;
\&
\&  say $entry\->offset; # returns an offset from the start of scan data stream 
\&  say $entry\->data_size;
\&  $entry\->dump;
\&  my $profile = Finnigan::Profile\->decode( \e*INPUT, $packet_header\->layout );
\&  say $profile\->first_value;
\&  say $profile\->nchunks;
\&  say $profile\->nbins;
\&  $profile\->set_converter( $converter_function_ref );
\&  my $bins = $profile\->bins; # calls the converter
\&  my ($mz, $abundance) = @{$bins\->[0]} # data in the first bin
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Finningan::Profile is a full-featured decoder for Finnigan scan
profiles. The data it generates contain the seek addresses, sizes and
types of all decoded elements, no matter how small. That makes it very
handy in the exploration of the file format and in writing new code,
but it is not very efficient in production work.
.PP
In performance-sensitive applications, the more lightweight
Finnigan::Scan module should be used, which includes
Finnigan::Scan::Profile and other related submodules. It can be used
as a drop-in replacement for the full-featured modules, but it does
not store the seek addresses and object types, greatly reducing the
overhead.
.PP
Every scan done in the \fBprofile mode\fR has a profile, which
is either a time-domain signal or a frequency spectrum accumulated in
histogram-like bins.
.PP
A profile can be either raw or filtered. Filtered profiles are sparse;
they consist of separate data chunks. Each chunk consists of a
contiguous range of bins containing the above-threshold signal. The
bins whose values fall below a cerain threshold are simply discarded,
leaving gaps in the profile \*(-- the reason for the ProfileChunk
structure to exist.
.PP
One special case is raw profile, which preserves all data. Since there
are no gaps in a raw profile, it is represented by a single chunk
covering the entire range of bins, so the same container structure is
suitable for complete profiles, as well as for sparse ones.
.PP
The bins store the signal intensity, and the bin co-ordinates are
typically the frequencies of Fourier-transformed signal. Since the
bins are equally spaced in the frequency domain, only the first bin
frequency is stored in each profile header. The bin width is common
for all bins and it is also stored in the same header. With these
data, it is possible to calculate the bin values based on the bin
indices.
.PP
The programs reading these data must convert the frequencies into the
M/z values using the conversion function specific to the type of
analyser used to acquire the signal. The calibrated coefficients for
this convesion function are stored in the ScanEvent structure (one
instance of this structure exists for every scan).
.PP
The \fBbins\fR method of Finnigan::Profile returns the converted bins,
optionally filling the gaps with zeroes.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.ie n .IP "decode($stream, $layout)" 4
.el .IP "decode($stream, \f(CW$layout\fR)" 4
.IX Item "decode($stream, $layout)"
The constructor method
.IP "nchunks" 4
.IX Item "nchunks"
Get the number of chunks in the profile
.IP "nbins" 4
.IX Item "nbins"
Get the total number of bins in the profile
.IP "first_value" 4
.IX Item "first_value"
Get the the value of the first bin in the profile
.IP "step" 4
.IX Item "step"
Get the bin width and the direction of change (the frequency step
needed to go from one bin to the next is a negative value)
.IP "chunk, chunks" 4
.IX Item "chunk, chunks"
Get the list of Finnigan::ProfileChunk? objects representing the profile data
.IP "set_converter($func_ref)" 4
.IX Item "set_converter($func_ref)"
Set the converter function (f \-> M/z)
.IP "set_inverse_converter($func_ref)" 4
.IX Item "set_inverse_converter($func_ref)"
Set the inverse converter function (M/z \-> f)
.IP "bins" 4
.IX Item "bins"
Get the reference to an array of bin values. Each array element
contains an (_M/z_, abundance) pair.
.IP "print_bins" 4
.IX Item "print_bins"
List the bin contents to \s-1STDOUT\s0
.SH "DEPRECATED"
.IX Header "DEPRECATED"
.IP "peak_count" 4
.IX Item "peak_count"
Replaced with \fBnchunks\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Finnigan::ProfileChunk
.PP
Finnigan::PacketHeader
.PP
Finnigan::Scan
.PP
Finnigan::Scan::Profile
.PP
Finnigan::ScanEvent
.PP
Finnigan::ScanIndexEntry
.PP
uf-scan
.SH "AUTHOR"
.IX Header "AUTHOR"
Gene Selkov, <selkovjr@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by Gene Selkov
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.10.0 or,
at your option, any later version of Perl 5 you may have available.
